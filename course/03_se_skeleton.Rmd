
---
title: "SummarizedExperiment 徹底ガイド: なぜ・何・どう使うか（airway_small 実データ版）"
author: "matsui-lab"
date: "`r format(Sys.Date())`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document:
    toc: true
    number_sections: true
editor_options:
  chunk_output_type: inline
---

# この資料のねらい

- 擬似データではなく **airway_small（500遺伝子 × 6サンプル）** を使って、`SummarizedExperiment` の**作り方・見方・使いどころ**を最短経路で理解する。  
- **一貫性の担保（アライメント）** と **再現性（保存・履歴）** を崩さずに、前処理→可視化→下流解析の入り口までをつなぐ。

# なぜ SummarizedExperiment なのか

- 行列（アッセイ）と **行メタ（rowData）**、**列メタ（colData）**、**解析メタ（metadata）** が**同一オブジェクトで同期**されるため、**列入れ替えやサブセットでも破綻しない**。  
- **自作の正規化結果**や**品質指標**を**別アッセイ**として追加でき、**切り替えて解析**できる（`assay(se, "something") <- ...`）。  
- **保存/復元**が簡単（`saveRDS()` / `readRDS()`）。

# 構造と用語

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.width = 7, fig.height = 4.5)
suppressPackageStartupMessages({
  library(readr); library(dplyr); library(tidyr); library(tibble)
  library(ggplot2)
  library(SummarizedExperiment); library(S4Vectors)
})

counts_path <- "~/r-gx-tutorial/data/processed/airway_counts_small.csv"
meta_path   <- "~/r-gx-tutorial/data/processed/airway_meta_small.csv"
```

## 最小例の作成（実データを安全に読み込む）

```{r load-data}
# 実データの読み込み
cts_tbl  <- readr::read_csv(counts_path, show_col_types = FALSE)
meta_tbl <- readr::read_csv(meta_path,   show_col_types = FALSE)

# 行（遺伝子）列（サンプル）の決定：counts は gene 列 + サンプル列（SRR*）
feature_col <- if ("gene" %in% names(cts_tbl)) "gene" else tail(names(cts_tbl), 1)
sample_cols <- setdiff(names(cts_tbl), feature_col)

# colData の並びを counts の列順に合わせる（base R で衝突回避）
stopifnot("sample_id" %in% names(meta_tbl))
meta_tbl$sample_id <- as.character(meta_tbl$sample_id)
meta_tbl <- meta_tbl[match(sample_cols, meta_tbl$sample_id), , drop = FALSE]

# counts 行列の構築（base R）
cts_df <- as.data.frame(cts_tbl, stringsAsFactors = FALSE)
cts_df <- cts_df[, c(feature_col, sample_cols), drop = FALSE]
rownames(cts_df) <- cts_df[[feature_col]]
cts_df[[feature_col]] <- NULL
cts_mat <- as.matrix(cts_df)
storage.mode(cts_mat) <- "integer"

# 一致確認
stopifnot(identical(colnames(cts_mat), meta_tbl$sample_id))

# rowData: ここでは gene のみを基本情報として格納（追加情報は後述で merge）
rd <- S4Vectors::DataFrame(gene = rownames(cts_mat))

# colData: group を factor 化（control / treatment）
meta_tbl$group <- factor(meta_tbl$group, levels = c("control","treatment"))
cd <- S4Vectors::DataFrame(meta_tbl)

# SE の作成
se <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = cts_mat),
  rowData = rd,
  colData = cd,
  metadata = list(
    source = "airway_small",
    created = Sys.time(),
    counts_path = counts_path,
    meta_path = meta_path
  )
)
se
```

# 玩具データ: 500 遺伝子 × 6 サンプル（実データの概要）

```{r overview}
dim(se)
head(assay(se, "counts")[, 1:3])
colData(se)
```

## 主要アクセサ

```{r accessors}
assay(se); assays(se); assayNames(se)
rowData(se)[1:5,]; colData(se); metadata(se)
```

# R の基本型と何が同じで何が異なるか

- `assay(se)` は **数値行列**（`matrix`）。行操作・列操作は **通常の行列と同様**に可能。  
- `rowData(se)` / `colData(se)` は **`S4Vectors::DataFrame`**（ほぼ `data.frame` と互換の操作感）。  
- 部分一致や**サブセット**は `se[rows, cols]` で **行列と同じ記法**だが、**メタも一緒に subset** される。

# 典型的ワークフロー（操作レシピ集）

## サブセット（行・列）

### 遺伝子タイプで行サブセット（例：上位可変遺伝子）

```{r subset-rows}
# 可変遺伝子ランキング（分散の大きい順に 200 個）
vars <- matrixStats::rowVars(assay(se, "counts"))
top200 <- order(vars, decreasing = TRUE)[1:200]
se_top <- se[top200, ]
dim(se_top)
```

### グループで列サブセット

```{r subset-cols}
se_ctrl  <- se[, colData(se)$group == "control"]
se_treat <- se[, colData(se)$group == "treatment"]
dim(se_ctrl); dim(se_treat)
```

## アッセイの追加・変換

### ライブラリサイズで簡易正規化（CPM ふうの比率）

```{r add-cpm}
libsize <- colSums(assay(se, "counts"))
cpm <- t(t(assay(se, "counts")) / libsize * 1e6)
assay(se, "cpm") <- cpm
assayNames(se)
```

### log 変換（log2-CPM）

```{r add-logcpm}
assay(se, "logcpm") <- log2(assay(se, "cpm") + 1)
assayNames(se)
```

## サンプルメタデータの加工（列側）

```{r mutate-coldata}
# 解析しやすいフラグ列：treatment=1, control=0
colData(se)$is_treat <- as.integer(colData(se)$group == "treatment")
colData(se)[, c("sample_id","group","is_treat")]
```

## 行メタデータの結合（行側）

### 例: 行統計（ベース平均・非ゼロ検出数）を rowData に追加

```{r join-rowdata}
base_mean <- rowMeans(assay(se, "counts"))
detected_in <- rowSums(assay(se, "counts") > 0)
rowData(se)$base_mean  <- base_mean
rowData(se)$detected_n <- detected_in
rowData(se)[1:5,]
```

# 例: 可視化（QC と構造の把握）

```{r viz-libsize}
df_lib <- data.frame(sample = colnames(se), libsize = colSums(assay(se, "counts")))
ggplot(df_lib, aes(x = sample, y = libsize)) + 
  geom_col() + coord_flip() + labs(title = "Library size per sample", y = "reads", x = NULL)
```

```{r viz-density}
mat <- assay(se, "logcpm")
df <- as.data.frame(mat)
df_long <- tidyr::pivot_longer(df, everything(), names_to = "sample", values_to = "logcpm")
ggplot(df_long, aes(x = logcpm, group = sample)) + 
  geom_density(alpha = 0.4) + labs(title = "log2-CPM density by sample")
```

```{r viz-pca}
# PCA on logcpm for top variable genes
vars <- matrixStats::rowVars(assay(se, "logcpm"))
sel <- order(vars, decreasing = TRUE)[1:200]
X <- t(assay(se, "logcpm")[sel, ])
p <- prcomp(X, scale. = TRUE)
aut <- as.data.frame(p$x[, 1:2])
aut$sample <- rownames(aut)
aut$group <- colData(se)$group[match(aut$sample, colData(se)$sample_id)]
ggplot(aut, aes(PC1, PC2, label = sample, color = group)) + 
  geom_point(size = 3) + ggrepel::geom_text_repel(show.legend = FALSE) + 
  labs(title = "PCA of top-variable genes (log2-CPM)") + theme(legend.position = "bottom")
```

# 事例集（レシピ）

## 事例 1: 低発現フィルタ→CPM→log2→デザイン行列

```{r recipe1}
# 低発現フィルタ (CPM > 1 in >= 2 samples)
cpm <- assay(se, "cpm")
keep <- rowSums(cpm > 1) >= 2
se_f <- se[keep, ]

# log2-CPM は既に "logcpm" として保持
dim(se_f)

# デザイン行列（群のみ）
design <- model.matrix(~ group, data = as.data.frame(colData(se_f)))
head(design)
```

## 事例 2: 列の並び替えと一括可視化

```{r recipe2}
ord <- order(colData(se)$group, colData(se)$sample_id)
se_ord <- se[, ord]
colData(se_ord)[, c("sample_id","group")]

# 並べ替え後のライブラリサイズ棒グラフ（group 列を明示して可視化）
df_lib2 <- data.frame(
  sample  = colnames(se_ord),
  libsize = colSums(assay(se_ord, "counts")),
  group   = as.factor(colData(se_ord)$group)
)

ggplot(df_lib2, aes(x = sample, y = libsize, fill = group)) +
  geom_col() + coord_flip() +
  labs(title = "Library size (ordered)", y = "reads", x = NULL)
```

## 事例 3: 正規化済みアッセイを追加して切替解析

```{r recipe3}
# 例: 中心化スケーリング（列 z-score）を別アッセイに
logcpm <- assay(se, "logcpm")
z <- scale(logcpm)  # 列ごとに標準化
assay(se, "zlogcpm") <- z
assayNames(se)

# 下流関数に渡すアッセイの切替は 1 行で OK
X1 <- assay(se, "logcpm")
X2 <- assay(se, "zlogcpm")
list(dim_logcpm = dim(X1), dim_zlogcpm = dim(X2))
```

# チェックリスト（実データへ差し替えるとき）

- [x] **列名と `colData$sample_id` の完全一致**を確認（`identical()`）。  
- [x] **重複行名なし**（`any(duplicated(rownames))`）。  
- [x] **アッセイの単位を明示**（`counts` / `cpm` / `logcpm` など）。  
- [x] **加工履歴を `metadata(se)` に追記**。  
- [x] **保存は `saveRDS(se, ...)`**、版管理は Git/LFS 等で。

# 付録: よく使う関数早見

```{r cheatsheet}
# アクセサ
assay(se); assays(se); assayNames(se)
rowData(se); colData(se); metadata(se)

# サブセット
se_sub <- se[1:10, 1:3]

# アッセイの追加
assay(se, "new") <- assay(se, "counts")

# 行列演算
rs <- rowSums(assay(se, "counts")); cs <- colSums(assay(se, "counts"))

# 保存/読み込み
# saveRDS(se, "se.rds"); se <- readRDS("se.rds")
```

# 保存

```{r save}
out_rds <- "~/r-gx-tutorial/data/processed/airway_se_small.rds"
saveRDS(se, out_rds)
out_rds
```

# Session info

```{r session-info}
sessionInfo()
```
