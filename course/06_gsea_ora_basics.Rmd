---
title: "06: 遺伝子セット解析（GSEA/ORA） 基礎と実践"
author: "集中講義"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: show
execute:
  echo: true
  warning: false
  message: false
editor: source
---

# ねらい / この章で学ぶこと

- 遺伝子セット解析の必要性・目的を理解する。
- **GSEA** と **ORA** の理論的な違い／実務上の使い分けを押さえる。
- R での実装（`clusterProfiler` / `fgsea` / `msigdbr` / `enrichplot` / *ReactomePA*）で、準備→解析→可視化までを再現可能に行う。
- 公的セット（MSigDB/GO/KEGG/Reactome）と **独自セット**（GMT/リスト）の扱いを学ぶ。

> 入力想定：前章の DGE 結果 `results/table/05_dge_all.csv`（列：`gene`, `log2FoldChange`, `pvalue` など）。

---

# 0. セットアップ（欠品パッケージを自動導入 & 可用時のみ利用）

```{r packages}
# ---- robust installer: CRAN vs Bioconductor ---------------------------------
install_if_missing <- function(cran_pkgs = character(), bioc_pkgs = character()) {
  # CRAN
  for (p in cran_pkgs) {
    if (!requireNamespace(p, quietly = TRUE)) {
      try(install.packages(p), silent = TRUE)
    }
  }
  # Bioconductor
  if (length(bioc_pkgs) > 0) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      try(install.packages("BiocManager"), silent = TRUE)
    }
    if (requireNamespace("BiocManager", quietly = TRUE)) {
      for (p in bioc_pkgs) {
        if (!requireNamespace(p, quietly = TRUE)) {
          try(BiocManager::install(p, ask = FALSE, update = FALSE), silent = TRUE)
        }
      }
    }
  }
}

cran_pkgs <- c("tidyverse", "here", "msigdbr", "readr", "ggplot2")
bioc_pkgs <- c("clusterProfiler", "fgsea", "enrichplot", "AnnotationDbi", "org.Hs.eg.db", "ReactomePA")

install_if_missing(cran_pkgs, bioc_pkgs)

suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
  library(msigdbr)
  library(clusterProfiler)
  library(fgsea)
  library(enrichplot)
  library(AnnotationDbi)
  # org.Hs.eg.db はヒト。別種は適宜変更。
  library(org.Hs.eg.db)
})

# Reactome は任意。利用可なら読み込み、不可ならスキップするフラグを立てる。
has_reactome <- requireNamespace("ReactomePA", quietly = TRUE)
if (has_reactome) {
  suppressPackageStartupMessages(library(ReactomePA))
} else {
  message("[NOTE] ReactomePA が見つからないため、Reactome 解析のコード塊はスキップします。")
}

# 出力先ディレクトリ
dir.create(here("results","fig"),   recursive = TRUE, showWarnings = FALSE)
dir.create(here("results","table"), recursive = TRUE, showWarnings = FALSE)
```

---

# 1. なぜ遺伝子セット解析か

- 個々の遺伝子での検定は **効果小・分散大** だと検出力が不足しがち。
- **機能的に関連する遺伝子群**は協調して変動する → 集約（セット）で見ると**検出力と解釈性**が向上。
- ORA は「**2 値化（入る/入らない）**」、GSEA は「**連続スコア（順位付け）**」を使う。

---

# 2. データの用意（ランクリスト & 背景集合）

```{r prepare}
# DGE 結果の読み込み（必要に応じてパスを調整）
dge <- readr::read_csv(here("results","table","05_dge_all.csv"), show_col_types = FALSE)

# ランク統計量（例）：符号付き log2FC × -log10(p)
rank_stat <- with(dge, sign(log2FoldChange) * -log10(pvalue))
ranks_tbl <- tibble(symbol = dge$gene, score = rank_stat) |>
  filter(!is.na(score)) |>
  arrange(desc(score))

# SYMBOL -> ENTREZID
map_tbl <- AnnotationDbi::select(org.Hs.eg.db,
                                 keys = ranks_tbl$symbol,
                                 keytype = "SYMBOL",
                                 columns = c("ENTREZID")) |>
  as_tibble() |>
  drop_na(ENTREZID) |>
  distinct(SYMBOL, .keep_all = TRUE)

rank_entrez <- ranks_tbl |>
  inner_join(map_tbl, by = c("symbol" = "SYMBOL")) |>
  transmute(ENTREZID, score)

ranks <- rank_entrez$score
names(ranks) <- rank_entrez$ENTREZID
ranks <- sort(ranks, decreasing = TRUE)

# ORA の背景集合（測定可能だった全遺伝子）
all_symbols <- dge$gene
all_entrez <- AnnotationDbi::select(org.Hs.eg.db, keys = all_symbols,
                                    keytype = "SYMBOL", columns = "ENTREZID") |>
  as_tibble() |>
  pull(ENTREZID) |>
  unique() |>
  na.omit()
```

---

# 3. 遺伝子セットの取得（MSigDB / GO 等）

```{r gene-sets}
# MSigDB: Hallmark を例示（他に C2/C5/C7 等）
msig_h <- msigdbr(species = "Homo sapiens", category = "H") |>
  select(gs_name, entrez_gene) |>
  group_by(gs_name) |>
  summarise(genes = list(unique(entrez_gene)), .groups = "drop")

pathways_h <- setNames(msig_h$genes, msig_h$gs_name)
length(pathways_h)
```

---

# 4. GSEA（fgsea / clusterProfiler）

```{r gsea-fgsea}
set.seed(1)
fg_res <- fgsea(pathways = pathways_h,
                stats    = ranks,
                minSize  = 15,
                maxSize  = 500,
                nperm    = 10000) |>
  arrange(padj)

readr::write_csv(fg_res, here("results","table","06_gsea_hallmark.csv"))
fg_res |>
  dplyr::select(pathway, NES, size, padj) |>
  head(10)
```

```{r gsea-fgsea-plot}
# 代表 1 経路のランニングスコアを保存
top1 <- fg_res$pathway[1]
plt <- fgsea::plotEnrichment(pathways_h[[top1]], ranks) + ggplot2::labs(title = top1)
ggplot2::ggsave(here("results","fig","06_gsea_top1.png"), plt, width = 6, height = 4)
```

```{r gsea-cp}
# GO Biological Process での GSEA
cp_go <- gseGO(geneList     = sort(ranks, decreasing = TRUE),
               OrgDb        = org.Hs.eg.db,
               ont          = "BP",
               minGSSize    = 15,
               maxGSSize    = 500,
               pvalueCutoff = 0.05,
               verbose      = FALSE)

enrichplot::dotplot(cp_go, showCategory = 15)
```

---

# 5. ORA（clusterProfiler）

```{r ora-go}
# 上位 300 の遺伝子（例）
top300 <- rank_entrez |>
  arrange(desc(score)) |>
  slice_head(n = 300) |>
  pull(ENTREZID)

ora_go <- enrichGO(gene          = top300,
                   universe      = all_entrez,
                   OrgDb         = org.Hs.eg.db,
                   keyType       = "ENTREZID",
                   ont           = "BP",
                   pAdjustMethod = "BH",
                   qvalueCutoff  = 0.1,
                   minGSSize     = 10,
                   maxGSSize     = 500)

readr::write_csv(as_tibble(ora_go@result), here("results","table","06_ora_go.csv"))
enrichplot::dotplot(ora_go, showCategory = 15) + ggplot2::labs(title = "ORA: GO (BP)")
```

```{r ora-reactome, eval=has_reactome}
# Reactome は利用可能な環境のみ実行
ora_reactome <- ReactomePA::enrichPathway(gene     = top300,
                                          universe = all_entrez,
                                          readable = TRUE)
readr::write_csv(as_tibble(ora_reactome@result), here("results","table","06_ora_reactome.csv"))
enrichplot::dotplot(ora_reactome, showCategory = 15) + ggplot2::labs(title = "ORA: Reactome")
```

---

# 6. 独自遺伝子セット（GMT/リスト）の利用

```{r custom-sets}
# 例（ENTREZID のベクトルリスト）
custom_sets <- list(
  MY_SIGNATURE_A = c("7157","1956","5290"),
  MY_SIGNATURE_B = c("7422","5290")
)

# ORA: enricher() で TERM2GENE を渡す
gs2gene <- stack(custom_sets) |>
  transmute(gs = ind, gene = values)

ora_custom <- enricher(gene = top300,
                       universe = all_entrez,
                       TERM2GENE = gs2gene,
                       pAdjustMethod = "BH")
enrichplot::dotplot(ora_custom) + ggplot2::labs(title = "ORA: Custom Gene Sets")

# GSEA: GSEA() でも TERM2GENE を渡せる
gsea_custom <- GSEA(geneList = sort(ranks, decreasing = TRUE),
                    TERM2GENE = gs2gene,
                    pvalueCutoff = 0.25)
enrichplot::gseaplot2(gsea_custom, geneSetID = gsea_custom@result$ID[1])
```

---

# 7. よくある落とし穴（チェックリスト）

- [ ] **ID タイプ一致**（SYMBOL/ENTREZID/ENSEMBL）。変換の重複は代表 1 つに集約。
- [ ] **背景集合（universe）** を適切に設定（ORA）。
- [ ] セットサイズの極端値（<10, >500）を除外。
- [ ] 多重検定補正（FDR/p.adjust）で解釈。
- [ ] GSEA は **NES の符号**で方向を解釈。ORA は up/down を分けて実行が安全。
- [ ] KEGG は仕様変更があるため、MSigDB 経由や Reactome 併用を推奨。

---

# 付記：再現性のために

```{r session-info}
readr::write_lines(capture.output(sessionInfo()), here("results","table","06_sessionInfo.txt"))
sessionInfo()
```
